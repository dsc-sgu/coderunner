use std::sync::Arc;

use tokio::sync::mpsc::channel;
use tokio_stream::wrappers::ReceiverStream;
use tonic::{Request, Response, Status};

use crate::{
    compiler::traits::Compiler,
    grpc::models::{
        SubmitCodeRequest, Task, TaskInCh, create_init_task, testing_service_server::TestingService,
    },
    pipeline::compiling::handle_compiling,
};

#[derive(Clone, Debug)]
pub struct TestingServiceImpl {
    compiler: Arc<dyn Compiler>,
}

impl TestingServiceImpl {
    pub fn new(compiler: Arc<dyn Compiler>) -> Self {
        Self { compiler }
    }
}

#[tonic::async_trait]
impl TestingService for TestingServiceImpl {
    type SubmitCodeStream = ReceiverStream<Result<Task, Status>>;

    // TODO: Implement
    #[tracing::instrument]
    async fn submit_code(
        &self,
        request: Request<SubmitCodeRequest>,
    ) -> Result<Response<Self::SubmitCodeStream>, Status> {
        tracing::info!("Received request: {:?}", request);

        // TODO: Think about 'pending' and 'accepted' states and request validation
        // TODO: Add limits to code size
        // TODO: Add limits to executable size
        // TODO: Don't use autogenerated grpc models in low layers

        // TODO: Remove magic numbers
        let (stream_tx, stream_rx) = channel(128);
        let (res_tx, mut res_rx) = channel::<TaskInCh>(128);
        let (run_tx, mut run_rx) = channel(128);
        let (compile_tx, compile_rx) = channel(128);

        let task = create_init_task();
        stream_tx
            .send(Ok(task.clone()))
            .await
            .expect("Failed to send task to stream_tx");
        compile_tx
            .send(TaskInCh {
                task,
                req: request.into_inner(),
            })
            .await
            .expect("Failed to send task to compile_tx");

        handle_compiling(res_tx, run_tx, compile_rx, self.compiler.clone());

        tokio::spawn(async move {
            while let Some(task) = run_rx.recv().await {
                tracing::debug!("Running: {:?}", task);
            }
        });

        tokio::spawn(async move {
            while let Some(task) = res_rx.recv().await {
                tracing::debug!("Send new state of task: {:?}", task);
                stream_tx
                    .send(Ok(task.task))
                    .await
                    .expect("Failed to send task to stream_tx");
            }
        });

        Ok(Response::new(ReceiverStream::new(stream_rx)))
    }
}
