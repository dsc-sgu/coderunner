use std::sync::Arc;

use tokio::sync::mpsc::{Receiver, Sender};

use crate::{
    compiler::{errors::CompilationError, traits::Compiler},
    grpc::models::{Empty, InvalidRequest, TaskInCh, task::State},
};

const TASK_TX_ERR: &'static str = "Failed to send task to task_tx";
const RUN_TX_ERR: &'static str = "Failed to send task to run_tx";

// TODO: Don't use autogenerated grpc models
#[tracing::instrument]
pub fn handle_compiling(
    res_tx: Sender<TaskInCh>,
    run_tx: Sender<TaskInCh>,
    mut compile_rx: Receiver<TaskInCh>,
    compiler: Arc<dyn Compiler>,
) {
    tokio::spawn(async move {
        while let Some(task) = compile_rx.recv().await {
            let compiler = compiler.clone();
            let res_tx = res_tx.clone();
            let run_tx = run_tx.clone();

            tokio::spawn(async move {
                let task = task.change_state(State::Compiling(Empty {}));
                res_tx.send(task.clone()).await.expect(TASK_TX_ERR);

                let Some(limits) = task.req.compilation_limits else {
                    let task = task.change_state(State::InvalidRequest(InvalidRequest {
                        message: "Compilation limits is not set".to_string(),
                    }));
                    res_tx.send(task).await.expect(TASK_TX_ERR);
                    return;
                };

                tracing::debug!("Start compiling");
                let compilation_result = compiler
                    .compile(&task.req.code, &task.req.language(), &limits)
                    .await;
                tracing::debug!("Compilation result: {:?}", compilation_result);

                match compilation_result {
                    Ok(_) => {
                        let task = task.change_state(State::Compiled(Empty {}));
                        run_tx.send(task.clone()).await.expect(RUN_TX_ERR);
                        res_tx.send(task).await.expect(TASK_TX_ERR);
                    }
                    Err(e) => match e {
                        CompilationError::CompilationFailed(info) => {
                            let task = task.change_state(State::CompilationFailed(info));
                            res_tx.send(task).await.expect(TASK_TX_ERR);
                        }
                        CompilationError::CompilationLimitsExceeded(info) => {
                            let task = task.change_state(State::LimitsExceeded(info));
                            res_tx.send(task).await.expect(TASK_TX_ERR);
                        }
                    },
                }
            });
        }
    });
}
